import {
  Project,
  QuoteKind,
  StructureKind,
  VariableDeclarationKind,
  type PropertySignatureStructure,
} from "ts-morph";
import type {
  EmissionOptions,
  EnumMember,
  MappedTable,
  TypeAst,
  TypeArg,
} from "./types.js";

/** Emit TypeScript source from mapped tables (ts-morph). */
export function emit(
  mapped: readonly MappedTable[],
  options: EmissionOptions,
): string {
  const project = new Project({
    useInMemoryFileSystem: true,
    manipulationSettings: { quoteKind: QuoteKind.Single },
  });
  const sf = project.createSourceFile("types.ts", "", { overwrite: true });

  const needsIPv4 = mapped.some((t) =>
    t.columns.some((c) => c.tsType === "IPv4"),
  );
  const needsIPv6 = mapped.some((t) =>
    t.columns.some((c) => c.tsType === "IPv6"),
  );
  const needsDecimal = mapped.some((t) =>
    t.columns.some((c) => c.tsType === "Decimal"),
  );
  const needsZod = options.emitZod;

  sf.addStatements([
    `/*\n * Generated by @ch2ts/core\n * Options: ${JSON.stringify(options)}\n */`,
  ]);

  if (needsZod) {
    sf.addImportDeclaration({ moduleSpecifier: "zod", namedImports: ["z"] });
  }
  if (needsDecimal) {
    sf.addImportDeclaration({
      moduleSpecifier: "decimal.js",
      isTypeOnly: true,
      namedImports: ["Decimal"],
    });
  }
  if (needsIPv4) {
    sf.addTypeAlias({
      isExported: true,
      name: "IPv4",
      type: `string & { readonly __brand: 'IPv4' }`,
    });
  }
  if (needsIPv6) {
    sf.addTypeAlias({
      isExported: true,
      name: "IPv6",
      type: `string & { readonly __brand: 'IPv6' }`,
    });
  }

  for (const table of mapped) {
    const props: PropertySignatureStructure[] = table.columns.map((c) => ({
      kind: StructureKind.PropertySignature,
      name: c.name,
      type: c.tsType,
      docs: [`Original: ${c.chType}${c.comment ? ` â€” ${c.comment}` : ""}`],
      hasQuestionToken: false,
    }));
    sf.addInterface({
      isExported: true,
      name: table.interfaceName,
      properties: props,
    });

    if (needsZod) {
      const zProps = table.columns
        .map((c) => `${c.name}: ${zodForTypeAst(c.typeAst, c.tsType)}`)
        .join(", ");
      sf.addVariableStatement({
        isExported: true,
        declarationKind: VariableDeclarationKind.Const,
        declarations: [
          {
            name: `${table.interfaceName}Schema`,
            initializer: `z.object({ ${zProps} })`,
          },
        ],
      });
    }
  }

  return sf.getFullText();
}

// Zod derivation (AST-aware)
function zodForTypeAst(type: TypeAst, resolvedTsType: string): string {
  switch (type.name) {
    case "Nullable": {
      const inner = firstTypeArg(type);
      return `${zodForTypeAst(inner, resolvedTsType)}.nullable()`;
    }
    case "LowCardinality": {
      const inner = firstTypeArg(type);
      return zodForTypeAst(inner, resolvedTsType);
    }
    case "Array": {
      const inner = firstTypeArg(type);
      return `z.array(${zodForTypeAst(inner, resolvedTsType)})`;
    }
    case "Tuple": {
      const entries = type.args
        .map(
          (a, i) =>
            `_${i}: ${zodForTypeAst(toTypeOrUnknown(a), resolvedTsType)}`,
        )
        .join(", ");
      return `z.object({ ${entries} })`;
    }
    case "Map": {
      const value = secondTypeArg(type);
      return `z.record(z.string(), ${zodForTypeAst(value, resolvedTsType)})`;
    }
    case "Enum8":
    case "Enum16": {
      const keys = type.args
        .map((a) =>
          typeof a === "object" && a !== null && "key" in a
            ? (a as EnumMember).key
            : undefined,
        )
        .filter((k): k is string => typeof k === "string");
      if (keys.length > 0) {
        const arr = `[${keys.map((k) => `'${k.replace(/'/g, "\\'")}'`).join(", ")}]`;
        return `z.enum(${arr})`;
      }
      return "z.string()";
    }
    case "Decimal":
      return "z.string()";
    case "Float32":
    case "Float64":
    case "Int8":
    case "Int16":
    case "Int32":
    case "UInt8":
    case "UInt16":
    case "UInt32":
      return "z.number()";
    case "Int64":
    case "UInt64":
      return /\bbigint\b/.test(resolvedTsType) ? "z.bigint()" : "z.string()";
    case "String":
    case "UUID":
    case "FixedString":
    case "IPv4":
    case "IPv6":
      return "z.string()";
    case "Date":
    case "DateTime":
    case "DateTime64":
      return /\bDate\b/.test(resolvedTsType) ? "z.date()" : "z.string()";
    default:
      return "z.any()";
  }
}

function isTypeAst(arg: TypeArg | undefined): arg is TypeAst {
  return (
    typeof arg === "object" && arg !== null && "name" in arg && "args" in arg
  );
}
function toTypeOrUnknown(arg: TypeArg | undefined): TypeAst {
  return isTypeAst(arg) ? arg : { name: "Unknown", args: [] };
}
function firstTypeArg(t: TypeAst): TypeAst {
  return toTypeOrUnknown(t.args[0]);
}
function secondTypeArg(t: TypeAst): TypeAst {
  return toTypeOrUnknown(t.args[1]);
}
