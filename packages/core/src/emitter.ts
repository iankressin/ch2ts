import {
  Project,
  QuoteKind,
  StructureKind,
  VariableDeclarationKind,
  IndentationText,
  type PropertySignatureStructure,
} from "ts-morph";
import type {
  EmissionOptions,
  EnumMember,
  MappedTable,
  TypeAst,
  TypeArg,
} from "./types.js";
import { assert, firstTypeArg, secondTypeArg, toTypeOrUnknown } from "./ast-utils.js";
type MappedColumn = MappedTable["columns"][number];

/** Emit TypeScript source from mapped tables (ts-morph). */
export function emit(
  mapped: readonly MappedTable[],
  options: EmissionOptions,
): string {
  assert(Array.isArray(mapped), "emit: mapped must be an array");
  const project = new Project({
    useInMemoryFileSystem: true,
    manipulationSettings: {
      quoteKind: QuoteKind.Double,
      indentationText: IndentationText.TwoSpaces,
      // Disable inserting indentation for new lines in object literals to match goldens
      // We'll control formatting in initializer strings ourselves.
    },
  });
  const sf = project.createSourceFile("types.ts", "", { overwrite: true });

  const needsIPv4 = mapped.some((t: MappedTable) =>
    t.columns.some((c: MappedColumn) => c.tsType === "IPv4"),
  );
  const needsIPv6 = mapped.some((t: MappedTable) =>
    t.columns.some((c: MappedColumn) => c.tsType === "IPv6"),
  );
  const needsDecimal = mapped.some((t: MappedTable) =>
    t.columns.some((c: MappedColumn) => c.tsType === "Decimal"),
  );
  const needsZod = options.emitZod;

  sf.addStatements([
    `/*\n * Generated by @ch2ts/core\n * Options: ${JSON.stringify(options)}\n */`,
  ]);

  if (needsZod) {
    sf.addImportDeclaration({ moduleSpecifier: "zod", namedImports: ["z"] });
  }
  if (needsDecimal) {
    sf.addImportDeclaration({
      moduleSpecifier: "decimal.js",
      isTypeOnly: true,
      namedImports: ["Decimal"],
    });
  }
  if (needsIPv4) {
    sf.addTypeAlias({
      isExported: true,
      name: "IPv4",
      type: `string & { readonly __brand: 'IPv4' }`,
    });
  }
  if (needsIPv6) {
    sf.addTypeAlias({
      isExported: true,
      name: "IPv6",
      type: `string & { readonly __brand: 'IPv6' }`,
    });
  }

  for (const table of mapped) {
    assert(table && Array.isArray(table.columns), "emit: table has no columns");
    const props: PropertySignatureStructure[] = table.columns.map((c: MappedColumn) => ({
      kind: StructureKind.PropertySignature,
      name: c.name,
      type: c.tsType,
      docs: [`Original: ${c.chType}${c.comment ? ` â€” ${c.comment}` : ""}`],
      hasQuestionToken: false,
    }));
    sf.addInterface({
      isExported: true,
      name: table.interfaceName,
      properties: props,
    });

    if (needsZod) {
      const entries = table.columns.map(
        (c: MappedColumn) => `${c.name}: ${zodForTypeAst(c.typeAst, c.tsType)}`,
      );
      const single = `{ ${entries.join(", ")} }`;
      const useMultiline = entries.length >= 15 || entries.length > 5 || single.length > 200;
      const initializer = useMultiline
        ? `z.object({\n${entries.map((e: string) => `  ${e},`).join("\n")}\n})`
        : `z.object(${single})`;
      sf.addVariableStatement({
        isExported: true,
        declarationKind: VariableDeclarationKind.Const,
        declarations: [
          {
            name: `${table.interfaceName}Schema`,
            initializer,
          },
        ],
      });
    }
  }

  return sf.getFullText();
}

// Zod derivation (AST-aware)
function zodForTypeAst(type: TypeAst, resolvedTsType: string): string {
  switch (type.name) {
    case "Nullable": {
      const inner = firstTypeArg(type);
      return `${zodForTypeAst(inner, resolvedTsType)}.nullable()`;
    }
    case "LowCardinality": {
      const inner = firstTypeArg(type);
      return zodForTypeAst(inner, resolvedTsType);
    }
    case "Array": {
      const inner = firstTypeArg(type);
      return `z.array(${zodForTypeAst(inner, resolvedTsType)})`;
    }
    case "Tuple": {
      const entries = type.args
        .map(
          (a, i) =>
            `_${i}: ${zodForTypeAst(toTypeOrUnknown(a), resolvedTsType)}`,
        )
        .join(", ");
      return `z.object({ ${entries} })`;
    }
    case "Map": {
      const value = secondTypeArg(type);
      return `z.record(z.string(), ${zodForTypeAst(value, resolvedTsType)})`;
    }
    case "Enum8":
    case "Enum16": {
      const keys = type.args
        .map((a) =>
          typeof a === "object" && a !== null && "key" in a
            ? (a as EnumMember).key
            : undefined,
        )
        .filter((k): k is string => typeof k === "string");
      if (keys.length > 0) {
        const arr = `[${keys.map((k) => `'${k.replace(/'/g, "\\'")}'`).join(", ")}]`;
        return `z.enum(${arr})`;
      }
      return "z.string()";
    }
    case "Decimal":
      return "z.string()";
    case "Float32":
    case "Float64":
    case "Int8":
    case "Int16":
    case "Int32":
    case "UInt8":
    case "UInt16":
    case "UInt32":
      return "z.number()";
    case "Int64":
    case "UInt64":
      return /\bbigint\b/.test(resolvedTsType) ? "z.bigint()" : "z.string()";
    case "String":
    case "UUID":
    case "FixedString":
    case "IPv4":
    case "IPv6":
      return "z.string()";
    case "Date":
    case "DateTime":
    case "DateTime64":
      return /\bDate\b/.test(resolvedTsType) ? "z.date()" : "z.string()";
    default:
      return safeZodFallback(resolvedTsType);
  }
}

// helpers moved to ast-utils.ts

function safeZodFallback(resolvedTsType: string): string {
  // Prefer stricter fallbacks when we can infer intent from the resolved TS type
  if (/\bDate\b/.test(resolvedTsType)) return "z.date()";
  if (/\bbigint\b/.test(resolvedTsType)) return "z.bigint()";
  if (/\bnumber\b/.test(resolvedTsType)) return "z.number()";
  if (/\bstring\b/.test(resolvedTsType)) return "z.string()";
  return "z.any()";
}
